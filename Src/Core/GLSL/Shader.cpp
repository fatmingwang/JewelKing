#include "../stdafx.h"
#include "GLSLUiniform.h"
#include "Shader.h"
#include "../GameplayUT/GameApp.h"
GLenum	g_iDrawindiceType = 
#ifndef __IPHONE__
GL_UNSIGNED_INT;
#else
GL_UNSIGNED_SHORT;
#endif
namespace FATMING_CORE
{
	GLuint	g_iMatrixVPLoacation;
	GLuint	g_iMatrixWLoacation;
	GLuint	g_iTexLoacation[8];//max support 8 texture
	GLuint	g_iBonesMatrixoacation;

	GLuint	g_iColorLoacation;
	GLuint	g_uiAttribArray[TOTAL_FVF];

	float	g_fViewProjectionMatrix[16];
	float	g_fWorldMatrix[16];

	cBaseShader*g_pCurrentShader = 0;

	cBaseShader::cBaseShader(WCHAR*e_strName,bool e_bNoTexture)
	{
		this->SetName(e_strName);
		m_bNoTexture = e_bNoTexture;
		m_uiTexLoacation = m_uiColorLoacation = m_uiMatrixVPLoacation = m_uiMatrixWLoacation = -1;
		memset(m_uiAttribArray,-1,sizeof(GLuint)*TOTAL_FVF);
		bool	l_b = CreateProgram(e_bNoTexture?g_strCommonVSNoTexture:g_strCommonVS,
									e_bNoTexture?g_strCommonFSNoTexture:g_strCommonFS,
									e_bNoTexture);
		assert(l_b);
	}

	cBaseShader::cBaseShader(char*e_strVS,char*e_strPS,WCHAR*e_strName,bool e_bNoTexture)
	{
		this->SetName(e_strName);
		m_bNoTexture = e_bNoTexture;
		m_uiTexLoacation = m_uiColorLoacation = m_uiMatrixVPLoacation = m_uiMatrixWLoacation = -1;
		memset(m_uiAttribArray,-1,sizeof(GLuint)*TOTAL_FVF);
		bool	l_b = CreateProgram(e_strVS,e_strPS,e_bNoTexture);
		assert(l_b);
	}

	cBaseShader::cBaseShader(WCHAR*e_strName,bool *e_pbClientState)
	{
		this->SetName(e_strName);
		for( int i=0;i<TOTAL_FVF;++i )
			m_uiAttribArray[i] = e_pbClientState[i]?1:-1;
	}

	cBaseShader::~cBaseShader()
	{
		glDeleteShader(m_uiVS);
		glDeleteShader(m_uiFS);
		glDeleteProgram( m_uiProgram );
	}

	bool	cBaseShader::CreateVS(char*e_strVS,bool e_bNoTexture)
	{
		m_uiVS = glCreateShader( GL_VERTEX_SHADER );
		const char*l_strVS[1] = {e_strVS};
		// Pass our sources to OpenGL. Our sources are NULL terminated, so pass NULL for the lenghts.
		glShaderSource( m_uiVS, 1, l_strVS, NULL );

		// Compile that one object.
		glCompileShader(m_uiVS);

		// Check for compilation success
		GLint compilationResult = 0;
		glGetShaderiv( m_uiVS, GL_COMPILE_STATUS, &compilationResult );
		FATMING_CORE::CheckShader(m_uiVS, GL_COMPILE_STATUS,L"Compile\n");
	   // current implementation always succeeds.
	   // The error will happen at link time.
	   if ( compilationResult == 0 )
	   {
	#ifdef WIN32
		  OutputDebugString(L"Failed to compile shader:\n");
	#endif
		  return false;
	   }
	   return true;
	}

	bool	cBaseShader::CreateFS(char*e_strPS,bool e_bNoTexture)
	{
		m_uiFS = glCreateShader( GL_FRAGMENT_SHADER );
		const char*l_strPS[1] = {e_strPS};
		// Pass our sources to OpenGL. Our sources are NULL terminated, so pass NULL for the lenghts.
		glShaderSource( m_uiFS, 1, l_strPS, NULL );

		// Compile that one object.
		glCompileShader(m_uiFS);

		// Check for compilation success
		GLint compilationResult = 0;
		glGetShaderiv( m_uiFS, GL_COMPILE_STATUS, &compilationResult );
		FATMING_CORE::CheckShader(m_uiFS, GL_COMPILE_STATUS,L"Compile\n");
	   // current implementation always succeeds.
	   // The error will happen at link time.
	   if ( compilationResult == 0 )
	   {
	#ifdef WIN32
		  OutputDebugString(L"Failed to compile shader:\n");
	#endif
		  return false;
	   }
	   return true;
	}

	GLuint	cBaseShader::GetUniFormLocationByName(const char*e_strName)
	{
		return glGetUniformLocation( m_uiProgram,e_strName);
	}

	bool	cBaseShader::CreateProgram(char*e_strVS,char*e_strPS,bool e_bNoTexture)
	{
		m_uiProgram = glCreateProgram();
		if( CreateVS(e_strVS,e_bNoTexture) )
		{
			if( CreateFS(e_strPS,e_bNoTexture) )
			{
				// Attach them to the program.
				glAttachShader( m_uiProgram, m_uiVS );
				glAttachShader( m_uiProgram, m_uiFS );
				// Link the whole program together.
				glLinkProgram( m_uiProgram );
				// Check for link success
				glUseProgram( m_uiProgram );
				if( FATMING_CORE::CheckProgram(m_uiProgram,GL_LINK_STATUS,L"link") )
				{
					//GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
					//GL_INVALID_OPERATION is generated if program is not a program object.
					//GL_INVALID_OPERATION is generated if program has not been successfully linked.
					if( !e_bNoTexture )
					{//there are 
						m_uiTexLoacation = glGetUniformLocation( m_uiProgram,"texSample" );
						glUniform1i( m_uiTexLoacation, 0 );
					}
					m_uiColorLoacation = glGetUniformLocation( m_uiProgram,"PSColor" );
					m_uiMatrixVPLoacation = glGetUniformLocation( m_uiProgram,"matVP" );
					m_uiMatrixWLoacation = glGetUniformLocation( m_uiProgram,"matW" );
					m_uiBonesLocation = glGetUniformLocation( m_uiProgram,"matBones" );

					for(int i=0;i<TOTAL_FVF;++i)
						m_uiAttribArray[i] = glGetAttribLocation(m_uiProgram, g_strShaderAttribution[i]);

					glLinkProgram( m_uiProgram );
					glUseProgram( m_uiProgram );
					return true;
				}
			}
		}
		return false;
	}

	void	cBaseShader::Use(bool e_bUseLastWVPMatrix)
	{
#ifndef OPENGLES_2_X
		glEnableClientState(GL_TEXTURE_COORD_ARRAY);
		if(m_uiAttribArray[FVF_TEX0]	!= -1)
		{
			glEnableClientState(GL_TEXTURE_COORD_ARRAY);
			glEnable(GL_TEXTURE_2D);
		}
		else
		{
			glDisableClientState(GL_TEXTURE_COORD_ARRAY);
			glDisable(GL_TEXTURE_2D);
		}
		if(m_uiAttribArray[FVF_NORMAL] != -1)
			glEnableClientState(GL_NORMAL_ARRAY);
		else
			glDisableClientState(GL_NORMAL_ARRAY);

		if(m_uiAttribArray[FVF_DIFFUSE]	!= -1)
			glEnableClientState(GL_COLOR_ARRAY);
		else
			glDisableClientState(GL_COLOR_ARRAY);
#else
		glUseProgram( m_uiProgram );
		//if u wanna to draw lines or else be careful the attribute array
		//0 for position,1 for UV,2 for color
		int	l_iIndex = 0;
		for( int i=0;i<TOTAL_FVF;++i )
		{
			if( m_uiAttribArray[i] == -1 )
			{
				glDisableVertexAttribArray( l_iIndex );
				++l_iIndex;
			}
		}
		for( int i=0;i<TOTAL_FVF;++i )
		{
			if( m_uiAttribArray[i] != -1 )
				glEnableVertexAttribArray( m_uiAttribArray[i] );
			//else
				//glDisableVertexAttribArray( m_uiAttribArray[i] );
		}
		if( m_uiTexLoacation != -1 )
			glUniform1i( m_uiTexLoacation, 0 );
		glActiveTexture( GL_TEXTURE0  );
		g_iMatrixVPLoacation =	m_uiMatrixVPLoacation;
		g_iMatrixWLoacation =		m_uiMatrixWLoacation;
		g_iColorLoacation =		m_uiColorLoacation;
		g_iBonesMatrixoacation =	m_uiBonesLocation;
		if( g_iColorLoacation != -1 )
			SetupShaderColor(Vector4::One);
		memcpy(g_uiAttribArray,m_uiAttribArray,sizeof(GLuint)*TOTAL_FVF);;
#endif
		if(e_bUseLastWVPMatrix)
		{
			SetupShaderViewProjectionMatrix(g_fViewProjectionMatrix);
			SetupShaderWorldMatrix(g_fWorldMatrix);
		}
	}
	void	cBaseShader::Disable()
	{
#ifdef OPENGLES_2_X
		for( int i=0;i<TOTAL_FVF;++i )
		{
			if( m_uiAttribArray[i] != -1 )
				glDisableVertexAttribArray( m_uiAttribArray[i] );
		}
		glUseProgram( 0 );
#endif
	}

	cObjectListByName<cBaseShader>*g_pAll2DShaderList = 0;


	cBaseShader*	CreateShader(bool *e_pbClientState,WCHAR*e_strName)
	{
		cBaseShader*l_p2DShader = 0;
		if( !g_pAll2DShaderList )
		{
			g_pAll2DShaderList = new cObjectListByName<cBaseShader>;
		}
		l_p2DShader = g_pAll2DShaderList->GetObject(e_strName);
		if( l_p2DShader )
			return l_p2DShader;
#ifdef OPENGLES_2_X
		glActiveTexture( GL_TEXTURE0  );
		l_p2DShader = new cBaseShader(e_strName,!e_pbClientState[FVF_DIFFUSE]);
#else
		l_p2DShader = new cBaseShader(e_strName,e_pbClientState);
		glEnableClientState(GL_VERTEX_ARRAY);
#endif
		g_pAll2DShaderList->AddObject(l_p2DShader);
		return l_p2DShader;
	}
	cBaseShader*	CreateShader(bool *e_pbClientState,char*e_strVS,char*e_strPS,WCHAR*e_strName)
	{
		glEnableClientState(GL_VERTEX_ARRAY);
		cBaseShader*l_p2DShader = 0;
		if( !g_pAll2DShaderList )
		{
			glActiveTexture( GL_TEXTURE0  );
			g_pAll2DShaderList = new cObjectListByName<cBaseShader>;
		}
		l_p2DShader = g_pAll2DShaderList->GetObject(e_strName);
		if( l_p2DShader )
			return l_p2DShader;
#ifdef OPENGLES_2_X
		glActiveTexture( GL_TEXTURE0  );
		l_p2DShader = new cBaseShader(e_strVS,e_strPS,e_strName,!e_pbClientState[FVF_DIFFUSE]);
#else
		l_p2DShader = new cBaseShader(e_strName,e_pbClientState);
		glEnableClientState(GL_VERTEX_ARRAY);
#endif
		g_pAll2DShaderList->AddObject(l_p2DShader);
		return l_p2DShader;
	}

	cBaseShader*	GetShader(WCHAR*e_strName)
	{
		if( !g_pAll2DShaderList )
		{
			return 0;
		}
		else
		{
			return g_pAll2DShaderList->GetObject(e_strName);
		}
	}

	bool	DeleteShader(WCHAR*e_strName)
	{
		bool l_b = false;
		if( g_pAll2DShaderList )
		{
			if( g_pAll2DShaderList->GetObject(e_strName) )
				l_b = g_pAll2DShaderList->RemoveObject(e_strName);
			if( g_pAll2DShaderList->Count() == 0 )
				SAFE_DELETE(g_pAll2DShaderList);
		}
		return l_b;
	}

	cBaseShader*	GetCurrentShader()
	{
		return g_pCurrentShader;
	}
	void	UseShaderProgram(cBaseShader*e_p2DShader)
	{
		if( !e_p2DShader )
			return;
		if( g_pCurrentShader && e_p2DShader == g_pCurrentShader )
			return;
		UseShaderProgram(e_p2DShader->GetName());
	}
	//only call once before draw any 2D image
	void	UseShaderProgram(const WCHAR*e_strName,bool e_bUseLastWVPMatrix)
	{
		if( g_pAll2DShaderList )
		{
			cBaseShader*l_p2DShader = g_pAll2DShaderList->GetObject(e_strName);
			if( l_p2DShader&&g_pCurrentShader && g_pCurrentShader == l_p2DShader )
				return;
			l_p2DShader->Use(e_bUseLastWVPMatrix);
			g_pCurrentShader = l_p2DShader;
		}
	}

	//only call once if u wanna to disable it.
	void	DisableShaderProgram(WCHAR*e_strName)
	{
		if( g_pAll2DShaderList )
		{
			cBaseShader*l_p2DShader = g_pAll2DShaderList->GetObject(e_strName);
			if( l_p2DShader )
				l_p2DShader->Disable();
			g_pCurrentShader = 0;
		}
	}
	//void	SetupWorldViewProjectionMatrix(float*e_pfWVPMatrix)
	//{
	//
	//}
	float*	GetCurrentViewProjectionMatrix()
	{
		return g_fViewProjectionMatrix;
	}
	void	SetupShaderViewProjectionMatrix(float*e_pfVPMatrix)
	{
		switch(cGameApp::m_seDeviceDirection)
		{
			case eDD_PORTRAIT:
				memcpy(g_fViewProjectionMatrix,e_pfVPMatrix,sizeof(float)*16);
				break;
			case eDD_UPSIDE_DOWN:
				memcpy(g_fViewProjectionMatrix,cMatrix44::ZAxisRotationMatrix(D3DXToRadian(180.f))*cMatrix44(e_pfVPMatrix),sizeof(float)*16);
				break;
			case eDD_LANDSCAPE_LEFT:
				memcpy(g_fViewProjectionMatrix,cMatrix44::ZAxisRotationMatrix(D3DXToRadian(90.f))*cMatrix44(e_pfVPMatrix),sizeof(float)*16);
				break;
			case eDD_LANDSCAPE_RIGHT:
				memcpy(g_fViewProjectionMatrix,cMatrix44::ZAxisRotationMatrix(D3DXToRadian(-90.f))*cMatrix44(e_pfVPMatrix),sizeof(float)*16);
				break;
		}
#ifdef OPENGLES_2_X
		glUniformMatrix4fv( g_iMatrixVPLoacation, 1, GL_FALSE, g_fViewProjectionMatrix);
#else
		glMatrixMode(GL_PROJECTION);
		glLoadMatrixf(g_fViewProjectionMatrix);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
#endif
	}


	void	SetupShaderWorldMatrix(float*e_pfWMatrix)
	{
		memcpy(g_fWorldMatrix,e_pfWMatrix,sizeof(float)*16);
#ifdef OPENGLES_2_X
		glUniformMatrix4fv( g_iMatrixWLoacation , 1, GL_FALSE, e_pfWMatrix);
#else
		glLoadMatrixf(e_pfWMatrix);
#endif
#ifdef _DEBUG
		MyGlErrorTest();
#endif
	}

	void	SetupShaderColor(Vector4 e_vColor)
	{
#ifdef OPENGLES_2_X
		glUniform4fv( g_iColorLoacation,1, (float*)&e_vColor);;
#else
		glColor4f(e_vColor.x,e_vColor.y,e_vColor.z,e_vColor.w);
#endif
#ifdef _DEBUG
		MyGlErrorTest();
#endif
	}

	void	SetupShaderBonesData(cMatrix44*e_pBoneMatrices,int e_iCount)
	{
#ifdef OPENGLES_2_X
		glUniformMatrix4fv( g_iBonesMatrixoacation , e_iCount, GL_FALSE, (float*)e_pBoneMatrices);
#else

#endif
#ifdef _DEBUG
		MyGlErrorTest();
#endif
	}

	void	MY_GLDRAW_ARRAYS(GLenum mode, GLint first, GLsizei count)
	{
#ifdef _DEBUG
		MyGlErrorTest();
#endif
		glDrawArrays(mode,first,count);
#ifdef _DEBUG
		MyGlErrorTest();
#endif
	}

	void	MY_GLDRAW_ELEMENTS(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
	{
		glDrawElements(mode,count,type,indices);
		//GL_NO_ERROR 0
		//GL_INVALID_ENUM 0x0500
		//GL_INVALID_VALUE 0x0501
		//GL_INVALID_OPERATION 0x0502
		int	l_i = glGetError();
		if( l_i != 0 )
		{
			bool	l_b0 = glIsEnabled(GL_VERTEX_ARRAY)==GL_TRUE;
			bool	l_b1 = glIsEnabled(GL_TEXTURE_COORD_ARRAY)==GL_TRUE;
			bool	l_b2 = glIsEnabled(GL_NORMAL_ARRAY)==GL_TRUE;
			bool	l_b3 = glIsEnabled(GL_COLOR_ARRAY)==GL_TRUE;
			int a=0;
		}
	}
}